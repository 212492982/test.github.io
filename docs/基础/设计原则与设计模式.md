# 设计原则

## 为什么要设计原则

> 为了有新需求是扩展即可，不会有修改带来的风险

##　设计原则有哪些

> 按照原则本身特性进行如下分类：
> - 为了不修改：单一职责、接口分离、依赖注入
> - 为了能扩展: 里氏替换、迪米特法则　（本质涉及抽象和实现）
> - 中心思想：开闭原则

## 设计原则总览

| 原则 | 英文解释 | 源自哪些问题 | 实践 |
| :---: | :---: | :---: | :---: | :---: |
| 单一职责 | SRP = Single Responsibility Principle | 如果多职责，修改时会影响太大 | 保证修改的理由只有一个，靠重构的封装和提炼 |
| 接口分离 | ISP = Interface Segregation Principle | 接口臃肿，被迫实现不需要的方法 | 适配器模式（很难识别是否要分离，有没有重构方法） |
| 依赖注入 | DIP = Dependence Inversion Principle | 总是要写单例模式，重复性工作 | 容器技术解决单例问题 |
| 里氏替换 | LSP = Liskov Substitution Principle | 继承并重写父类方法，那为何还要继承 | 不继承，改为依赖 |
| 迪米特法则 | LOD = Law Of Demeter | 调用还得知道实现细节 | 最少知识原则，接口、代理模式 |
| 开闭原则 | OCP = Open and Closed Principle | 经常需要修改 | 开放扩展，关闭修改，多态:重写、重载、接口继承 |

> 耦合程度递增：依赖 < 关联 < 聚合 < 组合
> - 依赖 Dependency 局部变量、方法形参、调用静态方法
> - 关联 Association 成员变量（但是同一层次）
> - 聚合 Aggregation [关联]成员变量（但是整体和部分的层次）
> - 组合 Aggregation [关联]整体要负责部分的生命周期

# 设计模式

## 设计模式简介

> Design Patterns
> GoF设计模式, Gang of Four四人组
> Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides
> 目的：高扩展, 少修改, 可复用

## 设计模式有那些

> - 创建型：简单工厂、工厂方法、抽象工厂、建造者、单例、原型
> - 结构型：代理
> - 行为型：策略

## 设计模式总览

| 类型 | 模式 | 英文解释 | 源自问题 | 使用场景 |
| :---: | :---: | :---: | :---: | :---: |
| 创建 | 简单工厂 | Factory | 源自问题 | 使用场景 |
| 创建 | 工厂方法 | Factory Method | 源自问题 | 使用场景 |
| 创建 | 抽象工厂 | Abstract Factory | 源自问题 | 使用场景 |
| 创建 | 建造者 | Builder | 源自问题 | 使用场景 |
| 创建 | 单例 | Singleton | 对象过多 | 被SpirngIOC方案所替代 |
| 创建 | 原型 | Multition or Prototype | － | 被SpirngIOC方案所替代 |
| 创建 | 代理 | Proxy | 源自问题 | JDK代理、CGLib、SpringAOP |
| 创建 | 策略 | Strategy | 源自问题 | 使用场景 |