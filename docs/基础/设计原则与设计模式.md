# 设计原则

## 为什么要设计原则

> 为了有新需求是扩展即可，不会有修改带来的风险

##　设计原则有哪些

> 按照原则本身特性进行如下分类：
> - 为了不修改：单一职责、接口分离、依赖注入
> - 为了能扩展: 里氏替换、迪米特法则　（本质涉及抽象和实现）
> - 中心思想：开闭原则

## 设计原则总览

| 原则 | 英文解释 | 源自哪些问题 | 实践 |
| :---: | :---: | :---: | :---: |
| 单一职责 | SRP = Single Responsibility Principle | 如果多职责，修改时会影响太大 | 保证修改的理由只有一个，靠重构的封装和提炼 |
| 接口分离 | ISP = Interface Segregation Principle | 接口臃肿，被迫实现不需要的方法 | 适配器模式（很难识别是否要分离，有没有重构方法） |
| 依赖注入 | DIP = Dependence Inversion Principle | 总是要写单例模式，重复性工作 | 容器技术解决单例问题 |
| 里氏替换 | LSP = Liskov Substitution Principle | 继承并重写父类方法，那为何还要继承 | 不继承，改为依赖 |
| 迪米特法则 | LOD = Law Of Demeter | 调用还得知道实现细节 | 最少知识原则，接口、代理模式 |
| 开闭原则 | OCP = Open and Closed Principle | 经常需要修改 | 开放扩展，关闭修改，多态:重写、重载、接口继承 |

> 耦合程度递增：依赖 < 关联 < 聚合 < 组合
> - 依赖 Dependency 局部变量、方法形参、调用静态方法
> - 关联 Association 成员变量（但是同一层次）
> - 聚合 Aggregation [关联]成员变量（但是整体和部分的层次）
> - 组合 Aggregation [关联]整体要负责部分的生命周期

# 设计模式

## 设计模式简介

> Design Patterns
> GoF设计模式, Gang of Four四人组
> Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides
> 目的：高扩展, 少修改, 可复用
> 教程: https://www.runoob.com/design-pattern/design-pattern-tutorial.html

## 设计模式有那些

> - 创建型（获取对象）：简单工厂、工厂方法、抽象工厂、建造者、单例、原型
> - 结构型（设计类）：代理、享元、桥接、装饰、组合、适配器、外观
> - 行为型（灵活方法）：迭代、模板、责任链、纪念品、中介、解释器、策略、状态、观察者、访问、命令

> Spring已经解决的设计模式：
> - 创建型：简单工厂、单例、原型
> - 结构型：代理

## 设计模式详解

### 代理

> 解释：不直接调用，而是通过同一接口另外一个实现调用
> 效果：拦截
> 场景：AOP、日志、脱敏

### 模板

> 解释：多个实现方法中大多相似代码，提炼到父类，保留相同代码，抽象不同代码
> 效果：方法合并重复代码，扩展实现只需要实现模板中的抽象方法
> 场景：还没碰到典型场景