- Java多线程与并发
  - 线程的基本使用
    - Thread、Runnable、Callable/Future
    - 生命周期：新建、就绪、运行、阻塞、死亡
      - 阻塞的情况
        - wait
        - lock
        - sleep/join
      - 终止的方式
        - 执行完成或异常
        - 退出标记，死循环的条件
        - interrupt
        - stop 太暴力，容易死锁，不用
      - 基本方法
        - wait
        - notify、notifyAll
        - sleep
        - join
        - yield 让步
      - 线程下上文切换
        - 进程与线程
        - 上下文 寄存器和程序计数器
        - 切换帧（switchframe）PCB, process control block
      - 守护线程
  - 线程池
    - 种类
      - ExecutorService
      - newCachedThreadPool
      - newFixedThreadPool
      - newScheduledThreadPool
      - newSingleThreadExecutor
    - 组成
    - 工作过程
      - 线程工作时，按优先级填满任务，核心>队列>最大数量>拒绝策略
      - 线程空出时，取出队列中的任务，没任务则走存活规则
    - 参数
      - 线程核心数量和最大数量
      - 超出核心数量的线程的存活时间
      - 任务队列
      - 线程工厂 Executors.defaultThreadFactory()
      - 拒绝策略
    - JDK拒绝策略
      - AbortPolicy 终止策略，抛RejectedExecutionException
      - CallerRunsPolicy 调用者运行策略
      - DiscardPolicy 丢弃策略
      - DiscardOldestPolicy 弃老策略
    - 阻塞队列
      - 原理
        - 队列空时消费阻塞
        - 队列满时生产阻塞
      - 方法
        - 非阻塞
          - add(e)、offer(e)、offer(e,time,unit)
          - remove()、poll()、poll(time,unit)、drainTo()
          - offer和poll返回true或false, drainTo一次取多个不用锁
        - 阻塞
          - put(e)
          - take()
      - 队列
        - BlockingQueue 接口
        - ArrayBlockingQueue 由数组结构组成的有界阻塞队列
        - LinkedBlockingQueue 由链表结构组成的有界阻塞队列 默认且容量为Integer.MAX_VALUE 容易OOM
        - PriorityBlockingQueue 支持优先级排序的无界阻塞队列
        - DelayQueue 使用优先级队列实现的无界阻塞队列
        - SynchronousQueue 不存储元素的阻塞队列 必须有个等待消费的，存进去时便直接消费，否则不能生产
        - LinkedTransferQueue 由链表结构组成的无界阻塞队列
        - LinkedBlockingDeque 由链表结构组成的双向阻塞队 工作窃取模式？
    - 栅栏
      - CountDownLatch 线程技术器 不可重用 主线程wait，所有子线程都countdown后主线程才能继续
      - CyclicBarrier 回环栅栏 可重用 所有线程都await即在栅栏前等待时才都可以进入下一个栅栏
      - Semaphore 信号量 根据设定数量new Semaphore(5)的许可限制同时访问数量acquire，释放许可release
  - 锁
    - 乐观锁
    - 悲观锁
    - 自旋锁
    - synchronized
      - 同步方法与同步块
        - 修饰静态方法 锁类
        - 修饰普通方法 锁对象
        - 修饰代码块 根据参数确定 如果是this或变量则是对象 如果是类或常量则是类
        - Order.class是Class对象，每个类有唯一的一个，锁类的时候就是锁Class对象
      - 种类
        - JDK6前 传统锁机制 系统函数 mutex futex
        - JDK6后 偏向锁和轻量级锁
      - 对象头 mark word
        - 32位 32字节 标记有 无锁态、重量级锁、轻量级锁、偏向锁、GC标记
        - 64位 64字节 未知结构
      - 重量级锁
        - 多线程竞争锁
        - mark word 指向堆中的monitor对象
          - monitor对象由3个链表结构cxq(ContentionLisst)、EntryList、WaitSet和2个线程OnDeck、Owner组成
          - 过程: 线程流向 cxq -> EntryList(<->WaitSet) -> OnDeck -> Owner
        - 被锁对象的 markword 会被通过 CAS 操作尝试更新为一个数据结构的指针， 这个数据结构中进一步包含了指向操作系统互斥量(mutex) 和 条件变量（condition variable） 的指针
      - 轻量级锁
        - 不同线程交替持有锁
        - mark word 指向栈帧中的Lock Record
          - LockRecord对象由原来mark word备份叫Displaced Mard Word和对象指针组成
          - 过程
            - 加锁：新建Lock Record, CAS指令修改mark word指向Lock Record, 如果失败说明未获得锁，修改Displaced Mard Word为null
            - 没有清楚锁膨胀怎么判断
            - 解锁：根据对象指针遍历Lock Record，如果Displaced Mark Word=null，则把指针也改成null，如果不为null，使用CAS指令复原mark word，成功则解锁，不成功则膨胀为重量级锁
      - 偏向锁
        - JDK6默认开启
        - -XX:BiasedLockingStartupDelay=0 偏向锁启动延时，不知道默认值是多少？
        - mark word格式为threadId + Epoch threadId初始为0 即 匿名偏向anonymously biased，Epoch用于批量重偏向
        - 加锁
          - threadId=0， CAS修改threadId为当前线程id，修改不成功则升级为轻量级锁
          - threadId=当前线程id，新建Lock Record, 其中Displaced Mark Word为空
          - threadId=别的线程id，解锁：在safepoint中查看偏向的线程是否存活，如果存活升级轻量级锁，如果不活，则将mark word改为无锁，并升级为轻量级锁
          - safepoint大概意思：代表了一个状态，在该状态下所有线程都是暂停的
        - 解锁
          - 最近一条lock record的指针改为null
        - 批量重偏向与撤销
          - 偏向锁撤销有一定成本，存在多线程锁竞争时，反而降低性能，因此需要批量重偏向与批量撤销的机制
          - 每个class维护一个撤销计数器
          - 批量重偏向：撤销次数达到批量重偏向阀值默认20
          - 批量撤销：撤销次数达到批量撤销阀值默认40，JVM认为该class存在多线程竞争，并标记为不可偏向，以后会直接走轻量级锁
        - 细节有理解不通的地方：1.解锁的操作怎么理解；2. 批量重偏向没看懂；
    - volatile
      - 正常情况是线程将
    - Atomic
  - 线程共享
  - 线程调度
  - CAS、AQS
  - 区别
    - wait/sleep
    - start/run
    - synchronized/ReentrantLock